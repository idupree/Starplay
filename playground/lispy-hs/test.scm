(letrec  ;or let* for the Y stuff
  (;(S (lambda (x y z) (x z (y z))))
;   (K (lambda (x y) x))
;   (I (lambda (x) x))
   ; hack since + etc isn't implemented yet:
   ;(+ 0) (* 0) (= 0) (- 0)
   (factorial (lambda (x) (if (= x 0) 1 (* x (factorial (- x 1))))))
   ;(fix (lambda (f) (f (fix f))
   ;λf.(λx.f (λv.((x x) v))) (λx.f (λv.((x x) v)))
   ;https://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator
   (Y (lambda (f)
      ((lambda (x) (f (lambda (v) ((x x) v))))
       (lambda (x) (f (lambda (v) ((x x) v)))))))
   (fac (lambda (rec) (lambda (x) (if (= x 0) 1 (* x (rec (- x 1)))))))
   (notfact (lambda (rec) (lambda (x) (* x 3))))
   ;(notfact2 (I notfact))
   (notfactorial2 (Y notfact))
   (curried+ (lambda (x) (lambda (y) (+ x y))))
   (factorial2 (Y fac))
   (f (lambda (x) (if (= x 4) 1 (* x (- x 1)))))
   (f2 (lambda (x) (+ (f1 x) 1)))
   (f1 (lambda (x) (+ x 1)))
  )
  ;(I I)
  (table-from-seq
    (f 4)
    (f2 4)
    ((curried+ 3) 4)
    (factorial 4)
    (factorial2 4))
  )
